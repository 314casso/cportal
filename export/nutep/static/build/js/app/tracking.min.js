(function () {
  'use strict';

  const utils = {		    
      reviver: function reviver(key, value) {
          const dateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/;
          if (typeof value === "string" && dateFormat.test(value)) {
              return new Date(value);
          }    
          return value;
      },
      checkJob: function (job, app) {					
          app.loading = true;			
          var xhr = new XMLHttpRequest();			
          if (!job) {									
              app.loading = false;
              return;
          }
          xhr.open('GET', '/api/jobstatus/' + job + '/');
          xhr.onload = function () {
              try {
                  var resp = JSON.parse(xhr.responseText);
              } catch (e) {
                  app.error = "Произошла ошибка обновления данных: " + e;
              }								
              if (resp.job == 'started') {					
                  setTimeout(utils.checkJob, 1000, job, app);
              } else {					
                  app.loading = false;					
                  if (resp.job == 'failed') {
                      app.error = "Произошла ошибка обновления данных";
                  } else {
                      app.jobSuccess();
                  }
              }
          };
          xhr.error = function (e) {
              app.loading = false;
              app.error = "Error " + e.target.status + " occurred while receiving the document.";
          };
          xhr.send();
      },
      pingData: function (url, app) {
          var xhr = new XMLHttpRequest();			
          app.loading = true;
          xhr.open('GET', url);
          xhr.onload = function () {
              var resp = JSON.parse(xhr.responseText);
              utils.checkJob(resp.job, app);
          };
          xhr.send();
      },
      
      shortdate: function (date) {
          if (date) {
              return moment(date).format('DD.MM.YY');
          }
      },    
      moment: function (date) {
          if (date) {
              return moment(date).format('DD.MM.YYYY HH:mm');
          }
      },
      upper: function (date) {
          if (date) {
              return date.toUpperCase();
          }
      },
      number: function(x) {
          return parseFloat(x).toString().replace(/\B(?=(\d{3})+(?!\d))/g, String.fromCharCode(160));
      }
    };

  var appTracking = new Vue({
      el: '#app-tracking',
      data: {
          items: [],
          loading: false,
          error: '',
          search: '',
          currentItem: null
      },
      delimiters: ["<%", "%>"],
      mounted() {
          if (this.$el) {
              this.fetchData();
              this.pingTracking();
          }
      },
      methods: {
          checkJob: function (job) {
              utils.checkJob(job, this);
          },
          jobSuccess: function () {
              this.fetchData();
          },
          pingTracking: function () {
              this.loading = true;
              utils.pingData('/api/pingtracking/', this);
          },
          fetchData: function () {
              console.log("fetchData");
              var xhr = new XMLHttpRequest();
              var self = this;
              xhr.open('GET', '/api/trackevents/');
              xhr.onload = function () {
                  try {
                      var data = JSON.parse(xhr.responseText, utils.reviver);
                      self.items = data;		
                      if (data && data[0].tracks) {				
                          data[0].tracks = data[0].tracks.slice().sort(function (a, b) {
                              return a.container.number.localeCompare(b.container.number);
                          });
                          self.currentItem = data[0].tracks[0];
                      }
                  } catch (e) {
                      self.error = "Произошла ошибка обновления данных: " + e;
                  }
              };
              xhr.send();
          },
          open: function (url) {
              window.location.href = url;
          },
          clearSearch: function () {
              this.search = "";
          },
          setCurrentItem: function (item) {
              this.currentItem = item;
          },
          itemTracks: function (item) {
              if (item) {
                  var tracks = item.tracks;
                  var self = this;
                  return tracks.filter(function (track) {
                      if (!self.search) {
                          return true;							
                      }												
                      return track.container.number.search(new RegExp(self.search, "i")) != -1; 
                  });				
              }				
          },
      },
      filters: {
          shortdate: function (date) {
              return utils.shortdate(date);
          },
          moment: function (date) {				
              return utils.moment(date);									
          },
          upper: function (date) {
              return utils.upper(date);					
          },
      },
  });

}());
