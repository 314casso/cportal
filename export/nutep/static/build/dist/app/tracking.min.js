'use strict';

(function () {
    'use strict';

    var utils = {
        reviver: function reviver(key, value) {
            var dateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/;
            if (typeof value === "string" && dateFormat.test(value)) {
                return new Date(value);
            }
            return value;
        },
        checkJob: function checkJob(job, app) {
            app.loading = true;
            var xhr = new XMLHttpRequest();
            if (!job) {
                app.loading = false;
                return;
            }
            xhr.open('GET', '/api/jobstatus/' + job + '/');
            xhr.onload = function () {
                try {
                    var resp = JSON.parse(xhr.responseText);
                } catch (e) {
                    app.error = "Произошла ошибка обновления данных: " + e;
                }
                if (resp.job == 'started') {
                    setTimeout(utils.checkJob, 1000, job, app);
                } else {
                    app.loading = false;
                    if (resp.job == 'failed') {
                        app.error = "Произошла ошибка обновления данных";
                    } else {
                        app.jobSuccess();
                    }
                }
            };
            xhr.error = function (e) {
                app.loading = false;
                app.error = "Error " + e.target.status + " occurred while receiving the document.";
            };
            xhr.send();
        },
        pingData: function pingData(url, app) {
            var xhr = new XMLHttpRequest();
            app.loading = true;
            xhr.open('GET', url);
            xhr.onload = function () {
                var resp = JSON.parse(xhr.responseText);
                utils.checkJob(resp.job, app);
            };
            xhr.send();
        },

        shortdate: function shortdate(date) {
            if (date) {
                return moment(date).format('DD.MM.YY');
            }
        },
        moment: function (_moment) {
            function moment(_x) {
                return _moment.apply(this, arguments);
            }

            moment.toString = function () {
                return _moment.toString();
            };

            return moment;
        }(function (date) {
            if (date) {
                return moment(date).format('DD.MM.YYYY HH:mm');
            }
        }),
        upper: function upper(date) {
            if (date) {
                return date.toUpperCase();
            }
        },
        number: function number(x) {
            return parseFloat(x).toString().replace(/\B(?=(\d{3})+(?!\d))/g, String.fromCharCode(160));
        }
    };

    var appTracking = new Vue({
        el: '#app-tracking',
        data: {
            items: [],
            loading: false,
            error: '',
            search: '',
            currentItem: null
        },
        delimiters: ["<%", "%>"],
        mounted: function mounted() {
            if (this.$el) {
                this.fetchData();
                this.pingTracking();
            }
        },

        methods: {
            checkJob: function checkJob(job) {
                utils.checkJob(job, this);
            },
            jobSuccess: function jobSuccess() {
                this.fetchData();
            },
            pingTracking: function pingTracking() {
                this.loading = true;
                utils.pingData('/api/pingtracking/', this);
            },
            fetchData: function fetchData() {
                console.log("fetchData");
                var xhr = new XMLHttpRequest();
                var self = this;
                xhr.open('GET', '/api/trackevents/');
                xhr.onload = function () {
                    try {
                        var data = JSON.parse(xhr.responseText, utils.reviver);
                        self.items = data;
                        if (data && data[0].tracks) {
                            data[0].tracks = data[0].tracks.slice().sort(function (a, b) {
                                return a.container.number.localeCompare(b.container.number);
                            });
                            self.currentItem = data[0].tracks[0];
                        }
                    } catch (e) {
                        self.error = "Произошла ошибка обновления данных: " + e;
                    }
                };
                xhr.send();
            },
            open: function open(url) {
                window.location.href = url;
            },
            clearSearch: function clearSearch() {
                this.search = "";
            },
            setCurrentItem: function setCurrentItem(item) {
                this.currentItem = item;
            },
            itemTracks: function itemTracks(item) {
                if (item) {
                    var tracks = item.tracks;
                    var self = this;
                    return tracks.filter(function (track) {
                        if (!self.search) {
                            return true;
                        }
                        return track.container.number.search(new RegExp(self.search, "i")) != -1;
                    });
                }
            }
        },
        filters: {
            shortdate: function shortdate(date) {
                return utils.shortdate(date);
            },
            moment: function moment(date) {
                return utils.moment(date);
            },
            upper: function upper(date) {
                return utils.upper(date);
            }
        }
    });
})();